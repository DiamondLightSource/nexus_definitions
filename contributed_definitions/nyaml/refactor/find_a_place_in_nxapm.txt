      # https://fairmat-experimental.github.io/nexus-fairmat-proposal/
      # 50433d9039b3f33299bab338998acb5335cd8951/classes/


  This application definition provides a place to document data and metadata to
  an atom probe experiment. Primarily the measurement itself is documented.
  However, as most atom probe experiments are controlled with commercial software
  which does not allow to access the raw detector hits, this application definition
  also includes two key groups of processing steps (reconstruction and ranging).
  
  During tomographic reconstruction measured data are processed into a point cloud
  of reconstructed positions of certain ions. During ranging time-of-flight data
  are identified as representing specific ions to annotate each ion with a label.
  
  Commercial software used in atom probe research is designed as an integrated
  acquisition and instrument control software. For AMETEK/Cameca local electrode
  atom probe (LEAP) instruments the least processed (rawest) numerical results
  and metadata are stored in so-called STR, RRAW, RHIT, and HITS files, which
  are proprietary and their file format specifications not publicly documented.
  
  Supplementary metadata are kept in a database (formerly known as the ISDb)
  which is connected to the instrument control software and synced with the
  experiment while ions are detected. In effect, RHIT and HITS files
  store the (rawest) experiment data in a closed manner that is
  practically useless for users unless they have access to the
  commercial software.
  
  To arrive at a state that atom probe microscopy (APM) with LEAP instruments
  delivers a dataset with which users can study reconstructed atomic
  position and do e.g. composition analyses or other post-processing
  analysis tasks, these raw data have to be processed. Therefore, it is
  necessary that for an application definition to be useful, details about
  the physical acquisition of the raw data and all its
  processing steps have to be stored.
  
  With this a user can create derived quantities like ion hit positions
  (on the detector) and calibrated time-of-flight data. These derived
  quantities are also needed to obtain calibrated mass-to-charge-state
  ratios, and finally the tomographic reconstruction of the ion positions.
  
  In most cases, an APM dataset is useful only if it gets post-processed
  via so-called ranging. Ranging defines rules for mapping time-of-flight
  and mass-to-charge-state ratio values on ion species. This is post-processing
  even though in practice it is performed sometimes already (as preview)
  already while data are still being collected.
  
  The ion types decode molecular identities which can very often be
  mapped to elemental identities, and also be used to distinguish isotopes.
  All these steps are in most cases performed using commercial software.
  
  Frequently, though, ranging and post-processing is also performed with
  (open-source) research software. Therefore, there is strictly speaking
  not a single program used throughout an atom probe analysis not even
  for the early stage of data acquisition and processing stages to obtain
  a useful reconstructed and ranged dataset.
  
  This application definition documents not only the measurement but also the
  key post-processing steps which transform the proprietary data into a
  tomographic reconstruction with ranging definitions.
  
  Future guidance by the technology partners like AMETEK/Cameca could improve
  this description to cover a substantial larger number of eventually metadata
  that so far are neither publicly documented nor accessible.
symbols:
  doc: |
    The symbols used in the schema to specify e.g. dimensions of arrays.
  n_ions: |
    Total number of ions collected.
  n_dld_wires: |
    Total number of independent wires in the delay-line detector.
  n_support: |
    Number of support points for e.g. modeling peaks.
  n_ivec_max: |
    Maximum number of allowed atoms per (molecular) ion (fragment).
    Needs to match maximum_number_of_atoms_per_molecular_ion.
  n_ranges: |
    Number of mass-to-charge-state-ratio intervals of this ion type.
  n_x: |
    Number of bins in the x direction.
  n_y: |
    Number of bins in the y direction.
  n_z: |
    Number of bins in the z direction.
  n_bins: |
    Number of bins.
  n_topology: |
    Total number of integers in the supplementary XDMF topology array.

# some consistence is not yet achieved with IFES_APT_TC APT HDF5 v1 format
# Language precision: Keywords such as “must” “required” “should”, etc are as per RFC-2119 [RFC2119]. https://tools.ietf.org/html/rfc2119
# https://gitlab.com/apt_software_toolbox/apt-hdf5 an implementation for an
# IFES APT TC APT HDF5 v1 verifier
# NEW ISSUE: possible offspring application definitions:
# NXapm_opt/pl would be possible, as soon as NXluminescence by Carola Emminger and Florian Dobner is ready whereby
# then there would be two subentries one for an NXapm and one for NXphotoluminesence to capture the photonic atom probe of Rouen/GPM
# and finally if there were an NXapm_afm for atomic force microscopy the IMEC AFM/APT experiments could be stored with an NXapm_afm application definition
# with NXapm and NXafm being respective subentries of the appdef but as NXapm_afm is a step-by-step approach one would have to release the constraint
# that only a single measurement can be performed.
# NXasat which could just take two subentries NXem and NXapm
# NXasat should be a fuse of NXapm and NXem within an NXentry with NXsubentry, in this way we can combine the strength of both application definitions
# to describe also the upcoming technique of atomic scale analytical tomography https://doi.org/10.1017/9781316677292



      
      # NEW ISSUE: atomic volume, detection efficiency, electric field (assumptions),
      # final specimen state, pre, post image analysis, a reference to three images
      # taken as recommended by cameca, before or after, radius evolution model, field # factor, image compression
      
      # default statistics would be good to report as output e.g.
      # total ions (single, multiple, partial) reconstructed ions (ranged, unranged)
      # voltage and bowl calibration (peak) mass_calibration as an own field
      
      # NEW ISSUE: check also here the PYCCAPT pipeline from P. Felfer's group
      ion_impact_positions(NXprocess):
        exists: recommended
        doc: |
          Details about where ions hit the ion_detector and data processing
          steps related to analog-to-digital conversion of detector signals
          into ion hit positions. For AMETEK LEAP instruments this processing
          takes place partly in the control unit of the detector partly
          in the software. The process is controlled by the acquisition/
          instrument control software (IVAS/APSuite/DAVis).
          The exact details are not documented by AMETEK in an open manner.
          For instruments built by individual research groups,
          like the Oxcart instrument, individual timing data from the
          delay-line detector are openly accessible.
        sequence_index(NX_POSINT):
          exists: recommended
        (NXprogram):
          exists: ['min', '1', 'max', 'unbounded']
          program:
            \@version:
        
        # NEW ISSUE: discuss with Oxcart developers which
        # modifications might be necessary here.
        arrival_time_pairs(NX_NUMBER):
          exists: recommended
          unit: NX_TIME
          doc: |
            Raw readings from the analog-to-digital-converter
            timing circuits of the detector wires.
          dimensions:
            rank: 3
            dim: [[1, n_ions], [2, n_dld_wires], [3, 2]]
        hit_positions(NX_NUMBER):
          unit: NX_LENGTH
          doc: |
            Evaluated ion impact coordinates at the detector
            (either as computed from the arrival time data
            or as reported by the control software).
            If the acquisition software enables it one can also store in this
            field the hit_positions, as measured by the detector, without any
            corrections.
          dimensions:
            rank: 2
            dim: [[1, n_ions], [2, 2]]
      
      # NEW ISSUE: follow the example of base_temperature_time_profile to monitor the temporal evolution of the detection_rate over the course of the evaporation sequence
      # detection_rate_time_profile(NX_FLOAT):
      # doc: Spatio-temporal profile of the detection rate since the start of the measurement.
      # NEW ISSUE: discuss how to handle cases when we would like to store ideally an array where one dimensions is NX_TIME and the other one is e.g. NX_PERCENT
      hit_quality_filtering(NXprocess):
        exists: optional
        doc: |
          This could be a place where currently the publicly undocumented
          algorithmic steps are stored how detected hits are judged for their
          quality. In CamecaRoot this there is something mentioned like
          golden and partial hits, here is where this could be documented.
        sequence_index(NX_POSINT):
          exists: recommended
      
      # NEW ISSUE: use symbols to monitor number of pulses
      hit_multiplicity(NXprocess):
        exists: recommended
        doc: |
          Data post-processing step which is, like the impact position analyses,
          usually executed in the integrated control software. This processing
          yields how many ions were detected with each pulse.
          
          It is possible that multiple ions evaporate and hit the same or
          different pixels of the detector on the same pulse.
          These data form the basis to analyses of the so-called
          (hit) multiplicity of an ion.
          
          Multiplicity must not be confused with how many atoms
          f the same element or isotope, respectively, a molecular
          ion contains (which is instead encoded with the
          isotope_vector field of each NXion instance).
        sequence_index(NX_POSINT):
          exists: recommended
        (NXprogram):
          exists: ['min', '1', 'max', 'unbounded']
          program:
            \@version:
        pulses_since_last_ion(NX_UINT):
          exists: recommended
          unit: NX_UNITLESS
          doc: |
            Number of pulses since the last detected ion pulse.
            For multi-hit records, after the first record, this is zero.
          dimensions:
            rank: 1
            dim: [[1, n_ions]]
        
        # NEW ISSUE: I feel the name is misleading, the quantity is
        # named like this de facto only because thats the jargon
        # term with epos files.
        pulse_id(NX_UINT):
          exists: optional
          unit: NX_UNITLESS
          doc: |
            Number of pulses since the start of the atom probe
            run/evaporation sequence.
          dimensions:
            rank: 1
            dim: [[1, n_ions]]
        hit_multiplicity(NX_UINT):
          unit: NX_UNITLESS
          
          # NEW ISSUE: further discussions with members of the APM community
          # is required to clarify this field and what it means
          doc: |
            Hit multiplicity.
          dimensions:
            rank: 1
            dim: [[1, n_ions]]
      ion_filtering(NXprocess):
        exists: recommended
        doc: |
          Like impact position and hit multiplicity computations,
          ion filtering is a data post-processing step with which users
          identify which of the detected ions should be included
          in the voltage-and-bowl correction.
          This post-processing is usually performed via GUI interaction
          in the reconstruction pipeline of IVAS/APSuite.
        sequence_index(NX_POSINT):
          exists: recommended
        (NXprogram):
          exists: ['min', '1', 'max', 'unbounded']
          program:
            \@version:
        evaporation_id_included(NX_BOOLEAN):
          doc: |
            Bitmask which is set to true if the ion
            is considered and false otherwise.
          dimensions:
            rank: 1
            dim: [[1, n_ions]]
      
      # NEW ISSUE: add section for propagation_delay(NXprocess) ?
      voltage_and_bowl_correction(NXprocess):
        exists: recommended
        doc: |
          Data post-processing step to correct for ion impact
          position flight path differences, detector biases,
          and nonlinearities. This step is usually performed
          with commercial software.
        sequence_index(NX_POSINT):
          exists: recommended
        (NXprogram):
          exists: ['min', '1', 'max', 'unbounded']
          program:
            \@version:
        
        # NEW ISSUE: realistic is that currently scientists can pull always a calibrated time-of-flight
        # but not necessarily unprocessed timing data from the detector (unless individuals built the instrument).
        # Relevant for ranging are the calibrated data, thats why only these
        # (as an intermediate/compromise solution) are required in this version of the application definition
        raw_tof(NX_FLOAT):
          exists: recommended
          unit: NX_TIME
          doc: |
            Raw time-of-flight data as read out from the acquisition software
            if these data are available and accessible.
          dimensions:
            rank: 1
            dim: [[1, n_ions]]
        calibrated_tof(NX_FLOAT):
          unit: NX_TIME
          
          # NEW ISSUE: which type of calibrations are applied is usually a modified
          # sqrt tof to m/q mapping the exact parameter of which are for LEAP instruments not immediately accessible.
          doc: |
            Calibrated time-of-flight.
          dimensions:
            rank: 1
            dim: [[1, n_ions]]
        tof_calibration(NXcollection):
          exists: recommended
          doc: |
            The key idea and algorithm of the voltage-and-bowl correction is
            qualitatively similar for instruments of different manufacturers
            or research groups.
            
            Specific differences exists though in the form of different
            calibration models. For now we do not wish to resolve or
            generalize these differences. Rather the purpose of this collection
            is to provide a container where model-specific parameters
            and calibration models can be stored if users know these
            for sure.
            
            For AMETEK LEAP instruments this should be the place for
            storing initial calibration values. These values are
            accessible normally only by AMETEK service engineers.
            They use these for calibrating the detector and instrument.
            
            Users can also use this NXcollection for storing the
            iteratively identified calibrations which scientists
            will see displayed in e.g. APSuite while they execute
            the voltage-and-bowl correction as a part of the
            reconstruction pipeline in APSuite.
      
      # NEW ISSUE: should be recommended as otherwise one cannot ensure that
      # numerically the same voltage-and-bowl correction results are obtained
      # (without knowning the parameters...)
      mass_to_charge_conversion(NXprocess):
        exists: recommended
        doc: |
          Data post-processing step in which calibrated time-of-flight data
          (ToF) are interpreted into mass-to-charge-state ratios.
        sequence_index(NX_POSINT):
          exists: recommended
        (NXprogram):
          exists: ['min', '1', 'max', 'unbounded']
          program:
            \@version:
        parameter(NXcollection):
          exists: recommended
          doc: |
            Store vendor-specific calibration models here (if available).
        mass_to_charge(NX_FLOAT):
          unit: NX_ANY
          doc: |
            Mass-to-charge-state ratio values.
          
          # \@units: Da / a unitless quantity because it is the charge state and not the charge
          dimensions:
            rank: 1
            dim: [[1, n_ions]]
      
      # NEW ISSUE: make this rather an own subentry NXapm_reconstruction
      reconstruction(NXprocess):
        exists: recommended
        doc: |
          Data post-processing step to create a tomographic reconstruction
          of the specimen based on selected calibrated ion hit positions,
          the evaporation sequence, and voltage curve data.
          Very often scientists use own software scripts according to
          published procedures, so-called reconstruction protocols,
          i.e. numerical recipes how to compute x, y, z atomic positions
          from the input data.
        sequence_index(NX_POSINT):
          exists: recommended
        (NXprogram):
          exists: ['min', '1', 'max', 'unbounded']
          program:
            \@version:
        protocol_name:
          doc: |
            Qualitative statement about which reconstruction protocol was used.
          enumeration: [bas, geiser, gault, cameca, other]
        parameter:
          
          # NEW ISSUE: the status here should be promoted to required but currently
          # one needs to manually extract the reconstruction parameters
          # NEW ISSUE: for instance from commercial software, here a better strategy
          # is needed how to document the reconstruction parameter.
          doc: |
            Different reconstruction protocols exist. Although these approaches
            are qualitatively similar, each protocol uses different parameters
            (and interprets these differently). The source code to IVAS/APSuite
            is not open. For now users should store reconstruction parameter
            in a collection.
        
        # k(NX_FLOAT):
        # doc: Field factor
        # unit: ??
        # icf(NX_FLOAT):
        # doc: Image compression factor.
        # unit: ??
        # NEW ISSUE: for AMETEK, as well as for the Bas, Geiser, and
        # Gault protocols we know the usual naming of the parameters
        # they should be added as optional quantities.
        # Therefore, it is difficult for now to generalize the meaning
        # and idea behind all relevant reconstruction parameters.
        # One could create a class for each reconstruction method, as
        # these methods are de facto application definitions.
        crystallographic_calibration:
          doc: |
            Different strategies for crystallographic calibration of the
            reconstruction are possible. The field is required and details
            should be specified in free-text at least. If the not crystallographic
            calibration was performed the field should be filled with the n/a,
            meaning not applied.
        reconstructed_positions(NX_FLOAT):
          unit: NX_LENGTH
          doc: |
            Three-dimensional reconstructed positions of the ions.
            Interleaved array of x, y, z positions in the specimen space.
          dimensions:
            rank: 2
            dim: [[1, n_ions], [2, 3]]
        visualization(NXprocess):
          exists: recommended
          xdmf_topology(NX_UINT):
            unit: NX_UNITLESS
            doc: |
              An array of triplets of integers which can serve as a supplementary
              array for Paraview to display the reconstructed dataset.
              The XDMF primitive type is here 1, the number of primitives 1 per
              triplet, the last integer in each triplet is the identifier of
              each point starting from zero.
            dimensions:
              rank: 1
              dim: [[1, n_topology]]
        
        # n_topology == 3*n_ions
        xdmf_topology(NX_UINT):
          unit: NX_UNITLESS
          doc: |
            Six equally formatted sextets chained together. For each
            sextett the first entry is an XDMF primitive topology
            key (here 5 for polygon), the second entry the XDMF primitive
            count value (here 4 because each face is a quad).
            The remaining four values are the vertex indices.
          dimensions:
            rank: 1
            dim: [[1, 36]]
        naive_point_cloud_density_map(NXprocess):
          doc: |
            To get a first overview of the reconstructed dataset,
            the format conversion computes a simple 3d histogram
            of the ion density using one nanometer cubic bins without
            applying smoothening algorithms on this histogram.
          (NXprogram):
            exists: ['min', '1', 'max', 'unbounded']
            program:
              \@version:
          (NXdata):
            doc: |
              A default three-dimensional histogram of the total
              number of ions in each bin obtained via using a rectangular
              transfer function.
            \@signal:
            \@axes:
            \@AXISNAME_indices:
            
            # \@long_name:
            title:
            data_counts(NX_NUMBER):
              unit: NX_UNITLESS
              doc: |
                Array of counts for each bin.
              dimensions:
                rank: 3
                dim: [[1, n_z], [2, n_y], [3, n_x]]
            axis_z(NX_FLOAT):
              unit: NX_LENGTH
              doc: |
                Bin center of mass position along the z axis.
              dimensions:
                rank: 1
                dim: [[1, n_z]]
              \@long_name:
            axis_y(NX_FLOAT):
              unit: NX_LENGTH
              doc: |
                Bin center of mass position along the y axis.
              dimensions:
                rank: 1
                dim: [[1, n_y]]
              \@long_name:
            axis_x(NX_FLOAT):
              unit: NX_LENGTH
              doc: |
                Bin center of mass position along the x axis.
              dimensions:
                rank: 1
                dim: [[1, n_x]]
              \@long_name:
      
      # NEW ISSUE: make this rather an own subentry NXapm_ranging
      ranging(NXprocess):
        exists: recommended
        doc: |
          Data post-processing step in which elemental, isotopic,
          and/or molecular identities are assigned to the ions.
          The documentation of these steps is based on ideas
          described in the literature:
          
          * `M. K. Miller <https://doi.org/10.1002/sia.1719>`_
          * `D. Haley et al. <https://doi.org/10.1017/S1431927620024290>`_
          * `M. Kühbach et al. <https://doi.org/10.1017/S1431927621012241>`_
        sequence_index(NX_POSINT):
          exists: recommended
        (NXprogram):
          exists: ['min', '1', 'max', 'unbounded']
          program:
            \@version:
        number_of_ion_types(NX_UINT):
          unit: NX_UNITLESS
          doc: |
            How many ion types are distinguished.
            If no ranging was performed each ion is of the special unknown type.
            The iontype ID of this unknown type is 0 which is a reserve value.
            Consequently, iontypes start counting from 1.
        maximum_number_of_atoms_per_molecular_ion(NX_UINT):
          unit: NX_UNITLESS
          doc: |
            Assumed maximum value that suffices to store all relevant
            molecular ions, even the most complicated ones.
            Currently a value of 32 is used.
        mass_to_charge_distribution(NXprocess):
          exists: recommended
          doc: |
            Specifies the computation of the mass-to-charge histogram.
            Usually mass-to-charge values are studied as an ensemble quantity,
            specifically these values are binned.
            This (NXprocess) stores the settings of this binning.
          (NXprogram):
            exists: ['min', '1', 'max', 'unbounded']
            program:
              \@version:
          range_minmax(NX_FLOAT):
            unit: NX_ANY
            doc: |
              Smallest and largest mass-to-charge-state ratio value.
            
            # \@units: Da
            # NEW ISSUE: NX_ATOMIC_MASS_UNIT use Tommasso scheme here Da
            dimensions:
              rank: 1
              dim: [[1, 2]]
          range_increment(NX_FLOAT):
            unit: NX_ANY
            doc: |
              Binning width of the mass-to-charge-state ratio values.
          
          # \@units: Da
          # NEW ISSUE: unit must match with range, is Da
          mass_spectrum(NXdata):
            doc: |
              A default histogram aka mass spectrum of
              the mass-to-charge-state ratio values.
            \@signal:
            \@axes:
            \@AXISNAME_indices:
            
            # \@long_name:
            title:
            data_counts(NX_NUMBER):
              unit: NX_UNITLESS
              doc: |
                Array of counts for each bin.
              dimensions:
                rank: 1
                dim: [[1, n_bins]]
              \@long_name:
            axis_mass_to_charge(NX_FLOAT):
              unit: NX_ANY
              doc: |
                Right boundary of each mass-to-charge-state ratio value bin.
              
              # \@units: Da
              dimensions:
                rank: 1
                dim: [[1, n_bins]]
              \@long_name:
        background_quantification(NXprocess):
          exists: recommended
          doc: |
            Details of the background model which was used to
            correct the total counts per bin into counts.
          (NXprogram):
            exists: ['min', '1', 'max', 'unbounded']
            program:
              \@version:
        
        # NEW ISSUE: add parameters of the background model in an e.g.
        # NXcollection as these are specific to every background model
        # NEW ISSUE: touching upon i.e. research activities by Andrew London et al.
        # substantiating the need for a clearer description how peak/signals were
        # eventually processed via deconvolution methods
        peak_search_and_deconvolution(NXprocess):
          exists: recommended
          doc: |
            How where peaks in the background-corrected in the histogram
            of mass-to-charge-state ratio values identified?
          (NXprogram):
            exists: ['min', '1', 'max', 'unbounded']
            program:
              \@version:
          (NXpeak):
            exists: ['min', '0', 'max', 'unbounded']
            label:
              exists: recommended
            peak_model:
              doc: |
                THIS DOCSTRING NEEDS CLARIFICATION.
        peak_identification(NXprocess):
          exists: recommended
          doc: |
            Details about how peaks, with taking into account
            error models, were interpreted as ion types or not.
          (NXprogram):
            exists: ['min', '1', 'max', 'unbounded']
            program:
              \@version:
          (NXion):
            exists: ['min', '0', 'max', '256']
            isotope_vector(NX_UINT):
            charge_state(NX_INT):
            mass_to_charge_range(NX_FLOAT):
            nuclid_list(NX_UINT):
              exists: recommended
            name:
              exists: recommended

    flight_path_geometry(NX_CHAR):
      doc: |
        Qualitative descriptor to distinguish flight_path geometries.
      enumeration: [straight, curved]
    flight_path_length(NX_FLOAT):
      doc: |
        The space inside the atom probe along which ions pass nominally
        when they leave the specimen and travel to the detector.
      unit: NX_LENGTH  # mm

    field_of_view(NX_FLOAT):  # property of the reconstruction!
      doc: |
        The nominal diameter of the specimen ROI which is measured in the
        experiment. It is important to mention that the physical specimen
        cannot be measured completely because ions may launch but not be
        detected or hit elsewhere in the analysis_chamber.
      unit: NX_LENGTH
	  
	  

      # NEW ISSUE: follow the example of base_temperature_time_profile to monitor the temporal evolution of the detection_rate over the course of the evaporation sequence
      # detection_rate_time_profile(NX_FLOAT):
      # doc: Spatio-temporal profile of the detection rate since the start of the measurement.
      # NEW ISSUE: discuss how to handle cases when we would like to store ideally an array where one dimensions is NX_TIME and the other one is e.g. NX_PERCENT