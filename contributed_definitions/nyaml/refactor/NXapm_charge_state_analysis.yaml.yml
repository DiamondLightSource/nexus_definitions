category: base
doc: |
  Base class to document an algorithm for recovering charge state and nuclid composition of a (molecular) ion.
  
  Currently used ranging definitions in the field of atom probe tomography face too problems:
  These definitions specify what are tags apply for all (molecular) ions with a mass-to-charge-state-ratio
  value within a specifed interval. Facing limited mass-resolving-power there are mass-to-charge-state-ratio
  values for which not only multiple (molecular) ions are indistinguishable but also the current documentation
  practice of classical ranging definitions is incomplete. 
  
  Usually ranging definitions report exclusively the mass-to-charge-state-ratio intervals
  surplus for each interval the composition of elements that build the (molecular) ion.
  However, nuclid and charge state information is not necessarily reported.
  
  Therefore, classical ranging definitions demand a post-processing with an algorithm
  which can identify the possible nuclid composition and thus the possible charge state
  if the (molecular) ion is indeed a candidate. Combinatorial algorithms are used for this
  purpose. This base class documents the parameter and results of such an algorithm.
symbols:
  doc: |
    The symbols used in the schema to specify e.g. dimensions of arrays.
  n_cand: |
    The number of also possible but different (molecular) ions.
  n_ivec_max: |
    Maximum number of allowed atoms per (molecular) ion (fragment).
type: group
NXapm_charge_state_analysis(NXprocess):
  doc: |
    Details and results of the combinatorial analyses of a ranging definition
    to clarify (if possible) the charge_state of an ion and its (not necessarily)
    unique combination of nuclids contained including their multiplicity.
  # input/config
  # element_vector(NX_UINT):
  mass_to_charge_range(NX_FLOAT):
    doc: |
      Input constraint, interval within which (molecular) ions need to have their
      mass-to-charge-state-ratio such that the ion qualifies as a candidate.
    unit: NX_ANY  # u
    dim: (1, 2)
  min_half_life(NX_FLOAT):
    doc: |
      Input constraint, minimum half life for how long each nuclid of each (molecular) ion
      needs to be stable such that the ion qualifies as a candidate.
    unit: NX_TIME
  min_abundance(NX_FLOAT):
    doc: |
      Input constraint, minimum natural abundance of each nuclid of each (molecular) ion
      such that the ion qualifies as a candidate.
    unit: NX_DIMENSIONLESS
    dim: (n_combinatorics,)
  sacrifice_isotopic_uniqueness(NX_BOOLEAN):
    doc: |
      If the value is zero/false it means that non-unique solutions are accepted.
      These are solutions where multiple candidates may differ in their isotopes but
      have the same charge.
  # output/results
  # the n_combinatorics can be 1 in which case all quantities below are scalar
  charge_state_vector(NX_INT):
    doc: |
      Charge state, i.e. integer multiple of the elementary charge.
    unit: NX_UNITLESS
    dim: (n_combinatorics,)
  isotope_matrix(NX_UINT):
    doc: |
      Specific nuclids building each candidate.
    unit: NX_UNITLESS
    dim: (n_combinatorics, n_ivec_max)
  mass_vector(NX_FLOAT):
    doc: |
      Accumulated mass of the isotopes in each candidate.
      Not corrected for quantum effects.
    unit: NX_MASS
    dim: (n_combinatorics,)
  natural_abundance_product_vector(NX_FLOAT):
    doc: |
      For each candidate the product of the natural abundances over the nuclids.
    unit: NX_DIMENSIONLESS
    dim: (n_combinatorics,)
  min_abundance_product(NX_FLOAT):
    doc: |
      For each candidate TO BE DEFINED.
    unit: NX_DIMENSIONLESS
    dim: (n_combinatorics,)
  min_half_life_vector(NX_FLOAT):
    doc: |
      For each candidate the half life of the nuclid with the smallest half_life.
    unit: NX_TIME
    dim: (n_combinatorics,)
