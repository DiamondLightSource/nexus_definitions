category: application
doc: |
  Application definition for results files of the paraprobe-transcoder tool.
  
  This tool is part of the paraprobe-toolbox. Inspect the base class :ref:`NXapm_paraprobe_tool_results`.
  The purpose and need of the paraprobe-transcoder tool is to create a standardized representation
  of reconstructed position and mass-to-charge-state-ratio values surplus other pieces of information
  to enable at all to work with atom probe data in reconstruction space.
  This includes ranging definitions which map mass-to-charge-state ratio values onto iontypes.
  So far the atom probe community has not yet agreed upon a comprehensive standardization for 
  information exchange especially when it comes to the communication of configurations and results
  from analyses of atom probe data. Instead, different simplistic file formats are used, such as POS , ePOS,
  APT, or RNG and RRNG. None of these formats document though the provenance of and thus the
  sequence in which certain analysis steps were performed on which specific input and using which
  specific configuration.
  
  Paraprobe-transcoder solves this limitation by interpreting the information content in such files
  and standardize the representation prior injection into the scientific data analysis tools of the toolbox.
  Therefore, the here proposed set of NeXus base classes and application definitions can be a useful
  starting point that enable the atom probe community to take advantage of standardized
  information exchange and improve the here proposed classes and concepts to become
  even more inclusive.
  
  Paraprobe-transcoder uses a Python library developed based on efforts by members of the
  global atom probe community `International Field Emission Society (IFES) Atom Probe Technical Committee (APT TC) <https://www.github.com/atomprobe-tc/ifes_apt_tc_data_modeling>`_. This library offers the
  actual low-level I/O operations and respective information interpretation.
symbols:
  doc: |
    The symbols used in the schema to specify e.g. dimensions of arrays.
  n_ions: |
    The total number of ions in the reconstruction.
  n_ivec_max: |
    Maximum number of allowed atoms per (molecular) ion (fragment).
    Needs to match maximum_number_of_atoms_per_molecular_ion.
  n_ranges: |
    Number of mass-to-charge-state-ratio intervals mapped on this ion type.
  n_topology: |
    Total number of integers in the supplementary XDMF topology array.
  n_combinatorics: |
    Number of ions probed in the combinatorial analysis of the charge states.
# i be careful n_comb can vary for every instance of (NXion) !
type: group
NXapm_paraprobe_transcoder_results(NXobject):
    # by default for appdefs the value of the exists keyword is required unless it is explicitly specified differently
  (NXentry):
    exists: ['min', '1', 'max', '1']
    \@version:
      doc: |
        Version specifier of this application definition.
    definition:
      doc: |
        Official NeXus NXDL schema with which this file was written.
      enumeration: [NXapm_paraprobe_transcoder_results]
    atom_probe(NXapm_paraprobe_tool_results):
      # this is currently a trick but should in the future be renamed to have a one-to-one
      # representation equivalence of reconstructed position and mass-to-charge-state-ratio value
      # arrays such that
      # the doc-string of the concept atom_probe(NXinstrument) should be used for
      # supplementary material to a paper but here no longer reported as it is way too specific
            # APSuite, RRNG, RNG, and NeXus/HDF5 NXapm in such a way that they can
      # be used with the tools of the paraprobe-toolbox.
      mass_to_charge_conversion(NXprocess):
        mass_to_charge(NX_FLOAT):
          unit: NX_ANY  # u
          doc: |
            Mass-to-charge-state-ratio values.
          dim: (n_ions,)
      reconstruction(NXprocess):
        reconstructed_positions(NX_FLOAT):
          \@depends_on(NX_CHAR):
            doc: |
              Point to the coordinate system in which these positions are defined.
          doc: |
            Three-dimensional reconstructed positions of the ions.
            Interleaved array of x, y, z positions in the specimen space.
          unit: NX_LENGTH
          dim: (n_ions, 3)
        visualization(NXprocess):
          exists: recommended
          xdmf_topology(NX_UINT):
            doc: |
              An array of triplets of integers which can serve as a supplementary
              array for Paraview to display the reconstruction. The XDMF datatype
              is here 1, the number of primitives 1 per triplet, the last integer
              in each triplet is the identifier of each point starting from zero.
            unit: NX_UNITLESS
            dim: (n_topology,)
      ranging(NXprocess):
        peak_identification(NXprocess):
          doc: |
            Details about how peaks, with taking into account
            error models, were interpreted as ion types or not.
          (NXion):
            exists: ['min', '1', 'max', '256']
            isotope_vector(NX_UINT):
            nuclid_list(NX_UINT):
              exists: recommended
            charge_state(NX_INT):
            mass_to_charge_range(NX_FLOAT):
              unit: NX_ANY  # u
              dim: (i, 2)
            # (NXcharge_state_model):
    (NXprogram):
    profiling(NXcs_profiling):
      start_time(NX_DATE_TIME):
      end_time(NX_DATE_TIME):
      status(NX_CHAR):
      results_path(NX_CHAR):
        exists: recommended
      total_elapsed_time(NX_NUMBER):
      number_of_processes(NX_POSINT):
      number_of_threads(NX_POSINT):
      number_of_gpus(NX_POSINT):
      # use more detailed constraint set to describe a computer
    (NXuser):
      exists: ['min', '0', 'max', 'unbounded']
      doc: |
        If used, metadata of at least the person who performed this analysis.
      name(NX_CHAR):
    (NXcoordinate_system_set):
      paraprobe(NXcoordinate_system):
        type(NX_CHAR):
        handedness(NX_CHAR):
        x(NX_NUMBER):
          unit: NX_LENGTH
          dim: (3,)
        y(NX_NUMBER):
          unit: NX_LENGTH
          dim: (3,)
        z(NX_NUMBER):
          unit: NX_LENGTH
          dim: (3,)
