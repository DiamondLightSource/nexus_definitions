<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="nxdlformat.xsl"?>
<!--
# NeXus - Neutron and X-ray Common Data Format
# 
# Copyright (C) 2014-2022 NeXus International Advisory Committee (NIAC)
# 
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# For further information, see http://www.nexusformat.org
-->
<definition xmlns="http://definition.nexusformat.org/nxdl/3.1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" category="application" name="NXebsd" extends="NXobject" type="group" xsi:schemaLocation="http://definition.nexusformat.org/nxdl/3.1 ../nxdl.xsd">
    <symbols>
        <symbol name="n_op">
            <doc>
                 Number of arguments per orientation for given parameterization.
            </doc>
        </symbol>
        <symbol name="n_sc">
            <doc>
                 Number of scan points.
            </doc>
        </symbol>
        <symbol name="n_z">
            <doc>
                 Number of pixel along the slowest changing dimension for a rediscretized, i.e.
                 standardized default orientation mapping.
            </doc>
        </symbol>
        <symbol name="n_y">
            <doc>
                 Number of pixel along slow changing dimension for a rediscretized i.e.
                 standardized default orientation mapping.
            </doc>
        </symbol>
        <symbol name="n_x">
            <doc>
                 Number of pixel along fast changing dimension for a rediscretized i.e.
                 standardized default orientation mapping.
            </doc>
        </symbol>
    </symbols>
    <doc>
         Application definition for indexing Kikuchi pattern into orientation maps.
         
         For so-called three-dimensional or serial sectioning EBSD it is necessary to
         follow a sequence of specimen, surface preparation, and data collection steps.
         Results from individual measurements are combined into one reconstructed stack.
         In this case, users should collect the data for each serial sectioning step
         via an own instance of NXebsd. To report the resulting post-processing of this
         set of EBSD (and/or orientation per scanned material point) users should use
         an instance of the NXms application definition. This application definition
         enables users to describe three-dimensional microstructures and features
         identified in these microstructures. The term microstructure is used here
         but is not restricted to features at the micron scale.
         Eventual tomography methods also use such a workflow because first diffraction
         images are collected and then these are indexed and composed into a 3D
         orientation mapping. The here proposed NXebsd application definition can
         give some conceptual ideas how this splitting between measurement and
         post-processing can be granularized also for these techniques.
    </doc>
    <group type="NXentry" minOccurs="1" maxOccurs="unbounded">
        <attribute name="version">
            <doc>
                 An at least as strong as SHA256 hashvalue of the file
                 that specifies the application definition.
            </doc>
        </attribute>
        <field name="definition">
            <doc>
                 NeXus NXDL schema to which this file conforms.
            </doc>
            <enumeration>
                <item value="NXebsd"/>
            </enumeration>
        </field>
        <field name="workflow_identifier">
            <doc>
                 Ideally, a (globally) unique persistent identifier
                 for referring to this workflow.
                 
                 The identifier is usually defined/issued by the facility, laboratory,
                 or the principle investigator. The identifier enables to link
                 workflows/experiments to e.g. proposals.
            </doc>
        </field>
        <field name="workflow_description" optional="true">
            <doc>
                 Free-text description about the workflow.
                 
                 Users are strongly advised to detail the sample history in the 
                 respective field and fill rather as completely as possible the fields
                 of the application definition behind instead of filling in these
                 details into the experiment_description free-text description field.
            </doc>
        </field>
        <field name="start_time" type="NX_DATE_TIME" recommended="true">
            <doc>
                 ISO 8601 time code with local time zone offset to UTC information
                 included when the processing of the workflow started.
                 If the application demands that time codes in this section of the
                 application definition should only be used for specifying when the
                 workflow was executed - and the exact duration is not relevant
                 - this start_time field should be used.
                 
                 Often though it is useful to specify a time interval with specifying
                 both start_time and end_time to allow for more detailed bookkeeping
                 and interpretation of the workflow.
            </doc>
        </field>
        <field name="end_time" type="NX_DATE_TIME" recommended="true">
            <doc>
                 ISO 8601 time code with local time zone offset to UTC included
                 when the processing of the workflow ended.
            </doc>
        </field>
        <field name="program">
            <doc>
                 Commercial, parser, or otherwise given name to the program
                 which was used to process the workflow.
            </doc>
            <attribute name="version">
                <doc>
                     Program version plus build number, commit hash, or description of an
                     ever persistent resource where the source code of the program and
                     build instructions can be found so that the program can be configured
                     in such a manner that the result file is ideally recreatable
                     yielding the same results.
                </doc>
            </attribute>
        </field>
        <group type="NXuser" minOccurs="0" maxOccurs="unbounded">
            <doc>
                 Optional contact information and eventually details of at least one person
                 involved in performing the workflow. This can be the principle investigator
                 who performed this experiment. Adding multiple users if relevant is
                 recommended.
            </doc>
            <field name="name">
                <doc>
                     Given (first) name and surname of the user.
                </doc>
            </field>
            <field name="affiliation" recommended="true">
                <doc>
                     Name of the affiliation of the user at the point in time
                     when the experiment was performed.
                </doc>
            </field>
            <field name="address" recommended="true">
                <doc>
                     Postal address of the affiliation.
                </doc>
            </field>
            <field name="email" recommended="true">
                <doc>
                     Email address of the user at the point in time when the experiment
                     was performed. Writing the most permanently used email is recommended.
                </doc>
            </field>
            <field name="orcid" recommended="true">
                <doc>
                     Globally unique identifier of the user as offered by services
                     like ORCID or ResearcherID. If this field is field the specific 
                     service should also be written in orcid_platform
                </doc>
            </field>
            <field name="orcid_platform" recommended="true">
                <doc>
                     Name of the OrcID or ResearcherID where the account
                     under orcid is registered.
                </doc>
            </field>
            <field name="telephone_number" optional="true">
                <doc>
                     (Business) (tele)phone number of the user at the point
                     in time when the experiment was performed.
                </doc>
            </field>
            <field name="role" recommended="true">
                <doc>
                     Which role does the user have in the place and at the point 
                     in time when the experiment was performed? Technician operating
                     the microscope. Student, postdoc, principle investigator, guest
                     are common examples.
                </doc>
            </field>
            <field name="social_media_name" optional="true">
                <doc>
                     Account name that is associated with the user
                     in social media platforms.
                </doc>
            </field>
            <field name="social_media_platform" optional="true">
                <doc>
                     Name of the social media platform where the account
                     under social_media_name is registered.
                </doc>
            </field>
        </group>
        <group name="commercial_on_the_fly_indexing" type="NXprocess">
            <doc>
                 An inspection of the availability of EBSD datasets with an open-source
                 license stored on public archive services like Zenodo revealed during
                 the implementation of a generic parser for EBSD data that such data are
                 in most cases stored in two ways: Case one was via a file in format used
                 by technology partners. This file contains result of an on-the-fly
                 executed indexing, i.e. processing of the Kikuchi pattern into scan point
                 positions, indexing solutions per scan point, and some quality descriptors
                 for the solutions as well as crystal structure and phase metadata.
                 Case two were raw pattern in some custom format often without a detailed
                 description of what the individual fields and data arrays resolve
                 except for some references to publications.
                 Therefore, we first need to collect how these files have been
                 generated. Ideally one would do so by creating a complete set of
                 information via e.g. NXem that could then be used via reading from
                 the information in the measurement group (see below) of this application
                 definition. However, in most cases this is not available.
                 
                 Therefore, this group stores key metadata about which results file
                 contain the EBSD mapping and which software was used (software name
                 and version with build number). These pieces of information support
                 the interpretation of specific metadata in these results file which
                 currently cannot or be interpreted completely or conceptually uniquely.
                 
                 Thereby this NXem_ebsd application definition solves two key documentation
                 tasks which are so far missing in the EBSD community. An instance
                 of the application definition (e.g. a NeXus/HDF5 file formatted according
                 to this application definition) stores the connection between the
                 microscope session and thus the sample and microscope settings, and
                 Kikuchi pattern, overview images etc. Furthermore, this application definition
                 connects these data to the conventions used, and the results file
                 which would otherwise also be ripped out of their context when using
                 many traditional procedures where EBSD data are indexed on-the-fly
                 and shared by just sharing the results file in the technology partner
                 specific formatting.
            </doc>
            <field name="program">
                <doc>
                     Commercial program which was used to index the EBSD data
                     incrementally after they have been captured and while the
                     microscope was capturing. This is the usual production workflow
                     how scanning electron microscopes are used when collecting
                     EBSD data.
                </doc>
                <attribute name="version">
                    <doc>
                         Program version plus build number, commit hash, or other description
                         of an ever persistent resource where the source code of the program and
                         build instructions can be found or at least more information about the
                         program in this version can be found. If all such information is not
                         available, like for commercial software, here the version number
                         and build number should be named. Use semantic versioning if possible.
                    </doc>
                </attribute>
            </field>
            <field name="results_file">
                <doc>
                     Name of the results file.
                </doc>
                <attribute name="version">
                    <doc>
                         Hash of that file.
                    </doc>
                </attribute>
            </field>
        </group>
        <group name="measurement" type="NXprocess">
            <doc>
                 Connection between the measurement of the Kikuchi pattern and the
                 processing of these into an orientation microscopy image.
            </doc>
            <field name="origin">
                <doc>
                     Name or link to an existent instance of an EBSD raw dataset inside an
                     NXem which has at least one NXimage_set_em_kikuchi instance.
                     The path to this instance in the origin has to be specified under path.
                     
                     When NXem is not used or the aim is to rather explore first how
                     community specific files with EBSD data, such as ANG, CPR, or HDF5-
                     based formats can be parsed from, inject here the name of that file.
                     
                     The em_om parser will currently not interpret the majority of the
                     many system and technique-specific metadata which come with the
                     files from e.g. technology partners. This is because the current
                     culture in the field in the EBSD community is that many of the metadata
                     fields are not in all cases fully documented. In addition, it is common
                     practice in the research field of EBSD that users transcode their raw
                     data into other formats so that these data can be interpreted by
                     specific software tools including commercial software from technology
                     partners other than the one which delivered the system that was e.g.
                     used when the raw data were collected.
                     As many of the file formats are not designed to communicate also then
                     the specifically and most importantly the eventually different context
                     of the metadata, we have opted for the first iteration of the implementation
                     to discard these metadata.
                     
                     Another reason for this choice was also to emphasize that in fact such
                     challenges do exist in the community and thus pointing them out may
                     support the discussion to arrive at eventually more complete solutions.
                     As developing these solutions, should not be our authority and necessarily
                     demands profits from feedback from the technology partners we have
                     opted for this intermediate approach.
                </doc>
                <attribute name="version">
                    <doc>
                         Commit identifying this resource.
                    </doc>
                </attribute>
            </field>
            <field name="path">
                <doc>
                     Path which resolves which specific NXimage_set_em_kikuchi instance
                     was used as the raw data to this EBSD data (post)-processing workflow.
                </doc>
            </field>
        </group>
        <group name="calibration" type="NXprocess" recommended="true">
            <doc>
                 The EBSD system, that is the electron gun, pole-piece, stage tilting,
                 and EBSD detector, as well as the gnomonic projection have to be
                 calibrated to achieve reliable results. Specifically,
                 the gnomonic projection has to be calibrated.
                 
                 In most practical cases, especially in engineering, there is a substantial
                 larger number of sessions where such a calibrated system is used
                 rather than recalibrated.
                 
                 In the first case the user assumes that the principle geometry of the
                 hardware components and the settings in the control and EBSD pattern
                 acquisition software is well calibrated. Consequently, users only pick
                 from an existent library of NXem_ebsd_crystal_structure_model
                 instances and use them to measure and index their data on-the-fly.
                 As a result an indexing is performed after/between the beam scanning
                 the specimen (depends on configuration).
                 Specifically, users load their specimen, typically create a coarse image
                 of the surface, set an approximate value for the calibrated working distance
                 then tilt, configure the microscope for collection quality data, then
                 configure the settings used for the calibrated EBSD system, pick one or
                 multiple ROIs and then measure (nowadays this is virtually always an
                 automated process which is in most cases unsupervised, running within the
                 allocated microscope session time slot, data are indexed on-the-fly, and
                 results file often automatically copied and/or archived in certain places.
                 The result of such an EBSD measurement is a set of usually proprietary
                 or open files from technology partners (EBSD system and microscope 
                 manufacturers).
                 
                 In the second case, the system is being calibrated during the session
                 using standards (silicon, quartz, or other common specimens).
                 There is usually one person in each lab responsible for doing such
                 calibrations.
            </doc>
            <field name="origin">
                <doc>
                     A link/cross reference to an existent instance of NXebsd with ideally
                     an associated instance of NXem detailed under measurement which informs
                     about the calibration procedures.
                </doc>
                <attribute name="version">
                    <doc>
                         Commit identifying this resource.
                    </doc>
                </attribute>
            </field>
            <field name="path">
                <doc>
                     Path which resolves which specific NXimage_set_em_kikuchi instance
                     was used as the raw data to this EBSD data (post)-processing workflow
                     when performing the calibration.
                </doc>
            </field>
        </group>
        <group name="conventions" type="NXem_ebsd_conventions">
            <group name="rotation_conventions" type="NXprocess">
                <field name="three_dimensional_rotation_handedness"/>
                <field name="rotation_convention"/>
                <field name="euler_angle_convention"/>
                <field name="axis_angle_convention"/>
                <field name="orientation_parameterization_sign_convention"/>
            </group>
            <group name="sample_reference_frame" type="NXprocess">
                <field name="reference_frame_type"/>
                <field name="xaxis_direction"/>
                <field name="yaxis_direction"/>
                <field name="zaxis_direction"/>
                <field name="origin"/>
            </group>
            <group name="detector_reference_frame" type="NXprocess">
                <field name="reference_frame_type"/>
                <field name="xaxis_direction"/>
                <field name="yaxis_direction"/>
                <field name="zaxis_direction"/>
                <field name="origin"/>
            </group>
            <group name="gnomonic_projection_reference_frame" type="NXprocess">
                <field name="reference_frame_type"/>
                <field name="xaxis_direction"/>
                <field name="yaxis_direction"/>
                <field name="zaxis_direction"/>
                <field name="origin"/>
            </group>
            <group name="pattern_centre" type="NXprocess">
                <field name="xaxis_boundary_convention"/>
                <field name="xaxis_normalization_direction"/>
                <field name="yaxis_boundary_convention"/>
                <field name="yaxis_normalization_direction"/>
            </group>
        </group>
        <group name="indexing" type="NXprocess">
            <doc>
                 OIM, orientation imaging microscopy. Post-processing of the Kikuchi
                 patterns to obtain orientations. Fundamentally different algorithms
                 can be used to index EBSD/EBSP pattern.
                 
                 Pattern indexing is comparing of diffraction pattern, measured
                 against assumed or simulated pattern. Quality descriptor are defined
                 based on which an indexing algorithms yields a quantitative measure of
                 how similar measured and assumed/simulated pattern are, and thus if
                 no, one, or multiple so-called solutions were found.
                 
                 Assumed or simulated pattern use kinematical or dynamical electron
                 diffraction theory. Hough transform (which is essentially a discretized
                 Radon transform, for details see e.g A short introduction to the Radon
                 and Hough transforms and how they relate by M. van Ginkel et al.).
                 Dictionary-based indexing methods are most increasingly becoming used also.
            </doc>
            <field name="method">
                <doc>
                     Principal algorithm used for indexing.
                </doc>
                <enumeration>
                    <item value="undefined"/>
                    <item value="hough_transform"/>
                    <item value="dictionary"/>
                    <item value="radon_transform"/>
                    <item value="other"/>
                </enumeration>
            </field>
            <group name="background_correction" type="NXprocess" optional="true">
                <doc>
                     Details about the background correction applied to each Kikuchi pattern.
                </doc>
            </group>
            <group name="binning" type="NXprocess" optional="true">
                <doc>
                     Binning i.e. downsampling of the pattern.
                </doc>
            </group>
            <group name="parameter" type="NXcollection" optional="true">
                <doc>
                     Specific parameter relevant only for certain algorithms used
                </doc>
            </group>
            <group type="NXem_ebsd_crystal_structure_model" minOccurs="1" maxOccurs="unbounded">
                <field name="crystallographic_database_identifier" recommended="true"/>
                <field name="crystallographic_database" recommended="true"/>
                <field name="unit_cell_abc" type="NX_FLOAT"/>
                <field name="unit_cell_alphabetagamma" type="NX_FLOAT"/>
                <field name="space_group"/>
                <field name="phase_identifier" type="NX_UINT"/>
                <field name="phase_name" recommended="true"/>
                <field name="atom_identifier"/>
                <field name="atom" type="NX_UINT"/>
                <field name="atom_positions" type="NX_FLOAT"/>
                <field name="atom_occupancy" type="NX_FLOAT"/>
                <field name="number_of_planes" type="NX_UINT"/>
                <field name="plane_miller" type="NX_NUMBER"/>
                <field name="dspacing" type="NX_FLOAT"/>
                <field name="relative_intensity" type="NX_FLOAT"/>
            </group>
            <field name="status" type="NX_UINT" optional="true" units="NX_UNITLESS">
                <doc>
                     Which return value did the indexing algorithm yield for each scan point.
                     Practically useful is to use an uint8 mask.
                     
                     * 0 - Not analyzed  
                     * 1 - Too high angular deviation  
                     * 2 - No solution  
                     * 100 - Success  
                     * 255 - Unexpected errors
                </doc>
                <dimensions rank="1">
                    <dim index="1" value="n_sc"/>
                </dimensions>
            </field>
            <field name="n_phases_per_scan_point" type="NX_UINT" units="NX_UNITLESS">
                <doc>
                     How many phases i.e. crystal structure models were used to index each
                     scan point if any? Let's assume an example to explain how this field
                     should be used: In the simplest case users collected one pattern for
                     each scan point and have indexed using one phase, i.e. one instance
                     of an NXem_ebsd_crystal_structure_model.
                     
                     In another example users may have skipped some scan points (not indexed)
                     them at all) and/or used differing numbers of phases for different scan
                     points.
                     
                     The cumulated of this array decodes how phase_identifier and phase_matching
                     arrays have to be interpreted. In the simplest case (one pattern per scan
                     point, and all scan points indexed using that same single phase model),
                     phase_identifier has as many entries as scan points
                     and phase_matching has also as many entries as scan points.
                </doc>
                <dimensions rank="1">
                    <dim index="1" value="n_sc"/>
                </dimensions>
            </field>
            <field name="phase_identifier" type="NX_UINT" units="NX_UNITLESS">
                <doc>
                     The array n_phases_per_scan_point details how the phase_identifier
                     and the phase_matching arrays have to be interpreted.
                     
                     For the example with a single phase phase_identifier has trivial
                     values either 0 (no solution) or 1 (solution matching
                     sufficiently significant with the model for phase 1).
                     
                     When there are multiple phases, it is possible (although not frequently
                     needed) that a pattern matches eventually (not equally well) sufficiently
                     significant with multiple pattern. This can especially happen in cases of
                     pseudosymmetry and more frequently with an improperly calibrated system
                     or false or inaccurate phase models e.g. (ferrite, austenite).
                     Having such field is especially relevant for recent machine learning
                     or dictionary based indexing schemes because in combination with
                     phase_matching these fields communicate the results in a model-agnostic
                     way.
                     
                     Depending on the n_phases_per_scan_point value phase_identifier and
                     phase_matching arrays represent a collection of concatenated tuples,
                     which are organized in sequence: The solutions for the 0-th scan point,
                     the 1-th scan point, the n_sc - 1 th scan point and omitting tuples
                     for those scan points with no phases according to n_phases_per_scan_point
                </doc>
                <dimensions rank="1">
                    <dim index="1" value="i"/>
                </dimensions>
            </field>
            <field name="phase_matching" type="NX_NUMBER" recommended="true" units="NX_UNITLESS">
                <doc>
                     One-dimensional array, pattern by pattern labelling the solutions found.
                     The array n_phases_per_scan_point has to be specified because it details
                     how the phase_identifier and the phase_matching arrays have to be interpreted.
                     See documentation of phase_identifier for further details.
                </doc>
                <dimensions rank="1">
                    <dim index="1" value="i"/>
                </dimensions>
            </field>
            <field name="phase_matching_descriptor">
                <doc>
                     Phase_matching is a descriptor for how well the solution matches or not.
                     Examples can be confidence index (ci), mean angular deviation (mad),
                     some AI-based matching probability (other), i.e. the details are implementation-specific.
                </doc>
                <enumeration>
                    <item value="undefined"/>
                    <item value="ci"/>
                    <item value="mad"/>
                    <item value="other"/>
                </enumeration>
            </field>
            <field name="orientation_parameterization">
                <doc>
                     How are orientations parameterized? Inspect euler_angle_convention
                     in case of using euler to clarify the sequence of rotations assumed.
                </doc>
                <enumeration>
                    <item value="euler"/>
                    <item value="axis_angle"/>
                    <item value="rodrigues"/>
                    <item value="quaternion"/>
                    <item value="homochoric"/>
                </enumeration>
            </field>
            <field name="orientation" type="NX_NUMBER" units="NX_ANY">
                <doc>
                     Matrix of parameterized orientations identified. The slow dimension 
                     iterates of the individual solutions as defined by n_phases_per_scan_point.
                     Values for phases without a solution should be correctly identified as
                     IEEE NaN.
                </doc>
                <dimensions rank="2">
                    <dim index="1" value="i"/>
                    <dim index="2" value="n_op"/>
                </dimensions>
            </field>
            <field name="scan_point_positions" type="NX_NUMBER" units="NX_LENGTH">
                <doc>
                     Matrix of calibrated centre positions of each scan point
                     in the sample surface reference system.
                </doc>
                <dimensions rank="2">
                    <dim index="1" value="n_sc"/>
                    <dim index="2" value="2"/>
                </dimensions>
            </field>
            <field name="hit_rate" type="NX_NUMBER" optional="true" units="NX_DIMENSIONLESS">
                <doc>
                     Fraction of successfully indexed pattern
                     of the set averaged over entire set.
                </doc>
            </field>
            <group name="region_of_interest" type="NXprocess" minOccurs="1" maxOccurs="1">
                <doc>
                     An overview of the entire area which was scanned.
                     For details about what defines the image contrast inspect descriptor.
                </doc>
                <field name="descriptor">
                    <doc>
                         Descriptor representing the image contrast.
                    </doc>
                    <enumeration>
                        <item value="band_contrast"/>
                    </enumeration>
                </field>
                <group name="roi" type="NXdata">
                    <field name="data" type="NX_NUMBER" units="NX_UNITLESS">
                        <dimensions rank="3">
                            <dim index="1" value="n_y"/>
                            <dim index="2" value="n_x"/>
                            <dim index="3" value="3"/>
                        </dimensions>
                        <attribute name="long_name">
                            <doc>
                                 Overview
                            </doc>
                        </attribute>
                    </field>
                    <field name="axis_y" type="NX_NUMBER" units="NX_LENGTH">
                        <doc>
                             Calibrated center of mass of the pixel along the slow axis.
                        </doc>
                        <dimensions rank="1">
                            <dim index="1" value="n_y"/>
                        </dimensions>
                        <attribute name="long_name">
                            <doc>
                                 Label for the y axis
                            </doc>
                        </attribute>
                    </field>
                    <field name="axis_x" type="NX_NUMBER" units="NX_LENGTH">
                        <doc>
                             Calibrated center of mass of the pixel along the fast axis.
                        </doc>
                        <dimensions rank="1">
                            <dim index="1" value="n_x"/>
                        </dimensions>
                        <attribute name="long_name">
                            <doc>
                                 Label for the x axis
                            </doc>
                        </attribute>
                    </field>
                </group>
            </group>
            <group name="ipf_mapID" type="NXprocess" minOccurs="1" maxOccurs="unbounded">
                <doc>
                     Default inverse pole figure (IPF) plot of the data specific for each
                     phase interpolated on a rectangular/cuboidal domain with square
                     pixels/voxels and the orientations colored according
                     to the coloring scheme used in the respective ipf_color_modelID/program.
                     
                     Most importantly as the parser is not performing the inverse pole figure
                     mapping it requires that this computation is stored inside the results_file
                     that is referred to under commercial_on_the_fly_indexing.
                     This example clearly shows the key limitation that is when the computational
                     steps of collecting the raw data and post-processing these with some
                     custom scripts like MTex or commercial tools. The limitation is that
                     the program which consumes this file, here the parser of the research
                     data management system, has not necessarily sufficient information
                     available to check if the injected orientation data and color models
                     are matching the conventions which get injected from the electronic
                     lab notebook into an instance of this application definition, such
                     as a NeXus/HDF5 file that is formatted according to NXem_ebsd.
                     
                     Ideally, the parser would load convention-compliant EBSD data
                     and use subsequently a community library to transcode/convert orientations
                     eventually. Thereafter, convention-compliant default plot(s) could
                     be created and served for purposes of data exploration within the RDMS.
                     
                     Given the variety of post-processing tools used for EBSD however, and
                     the fact that these are not usually executed along standardized
                     post-processing workflows which perform exactly the same algorithmic steps,
                     this is currently not a practically implementable option because
                     at least one developer who would pursue such task would first have to
                     create a library for performing such tasks for the parser.
                     The unfortunate situation in EBSD is that due to historical reasons
                     and competitive strategies different players in the field have
                     implemement slightly different approaches each of which misses
                     one consistent view of the entire workflow that is EBSD analyses:
                     Sample preparation, measurement, indexing, post-processing, paper...
                     
                     The default plot does so far not
                     yet apply relevant rotations but takes the orientation
                     values as. Ideally with all conventions defined it can
                     be possible to develop a converter which rotates the
                     input data but this is here not yet assumed to happen.
                     
                     The key point is that the conventions however are captured
                     first of all because then such conversions for improving
                     interoperability can be achieved.
                     
                     This default gridded representation of the data should not be
                     misinterpreted as the only possible way how EBSD data and OIM
                     maps can be created.
                     
                     Indeed, the most general case is that patterns are collected for
                     scan points. The scan generator of an electron microscope is instructed
                     to steer the beam in such a way across the specimen surface that the beam
                     illuminates certain positions for a certain amount time (usually equally-
                     spaced and same time spent at each position).
                     
                     Scan positions can be such regular flight plans mapping lines,
                     line stacks, rectangular regions-of-interests, but also could instruct
                     spiral, random, or adaptive scans instead of square or hexagon grids.
                     
                     The majority of EBSD maps is reporting results for a regular grid
                     (square, hexagon). What matters though in terms of damage induced by
                     the electron beam and signal quality is the real electron dose history,
                     i.e. for how long the beam exposed which location for how long.
                     
                     Specifically the default visualization is an inverse pole-figure (IPF)
                     map with the usual RGB color coding. Different strategies and
                     normalization schemes are in use to define such color coding.
                </doc>
                <field name="phase_identifier" type="NX_UINT" units="NX_UNITLESS">
                    <doc>
                         Specifying which phase this IPF mapping visualizes.
                    </doc>
                </field>
                <field name="description" optional="true">
                    <doc>
                         Which IPF definition computation according to backend.
                    </doc>
                </field>
                <field name="projection_normal" type="NX_NUMBER" units="NX_DIMENSIONLESS">
                    <doc>
                         Along which axis to project? Typically [0, 0, 1] is chosen.
                    </doc>
                    <dimensions rank="1">
                        <dim index="1" value="3"/>
                    </dimensions>
                </field>
                <field name="bitdepth" type="NX_UINT" units="NX_UNITLESS">
                    <doc>
                         Bitdepth used for the RGB color model. Usually 8 bit.
                    </doc>
                </field>
                <field name="program">
                    <doc>
                         The tool/implementation used for creating the IPF color map from
                         the orientation data. Effectively this program is the backend
                         which performs the computation of the inverse pole figure mappings
                         to reflect what the EBSD community expects and solve also eventual
                         limitation of research data management system that their data
                         ingestion backends parsers do not have sophisticated software tools
                         in place to compute such community-specific default plots.
                         Seeing first of all that different tools may yield different color
                         maps may help to convince the community to work towards a common
                         library which transcodes between all possible relations.
                         In fact while working on this example I found as many different as
                         in backend.
                         
                         This is why it is critical to store all rotation_conventions
                         and reference frame details as detailed as possible because
                         then one can always post-process the data.
                    </doc>
                    <enumeration>
                        <item value="brinckmann"/>
                        <item value="mtex"/>
                        <item value="kikuchipy"/>
                        <item value="dream3d"/>
                        <item value="orix"/>
                        <item value="tsl"/>
                    </enumeration>
                    <attribute name="version">
                        <doc>
                             Version of the program i.e. backend used.
                        </doc>
                    </attribute>
                </field>
                <group name="ipf_rgb_map" type="NXdata">
                    <field name="data" type="NX_UINT" units="NX_UNITLESS">
                        <doc>
                             RGB array, with resolution per fastest changing value defined by bitdepth.
                        </doc>
                        <dimensions rank="3">
                            <dim index="1" value="n_y"/>
                            <dim index="2" value="n_x"/>
                            <dim index="3" value="3"/>
                        </dimensions>
                        <attribute name="long_name">
                            <doc>
                                 IPF color coded orientation mapping
                            </doc>
                        </attribute>
                    </field>
                    <field name="axis_y" type="NX_NUMBER" units="NX_LENGTH">
                        <doc>
                             Calibrated center of mass of the pixel along the slow axis.
                        </doc>
                        <dimensions rank="1">
                            <dim index="1" value="n_y"/>
                        </dimensions>
                        <attribute name="long_name">
                            <doc>
                                 Label for the y axis
                            </doc>
                        </attribute>
                    </field>
                    <field name="axis_x" type="NX_NUMBER">
                        <doc>
                             Calibrated center of mass of the pixel along the fast axis.
                        </doc>
                        <dimensions rank="1">
                            <dim index="1" value="n_x"/>
                        </dimensions>
                        <attribute name="long_name">
                            <doc>
                                 Label for the x axis
                            </doc>
                        </attribute>
                    </field>
                </group>
                <group name="ipf_rgb_color_model" type="NXdata">
                    <doc>
                         For each stereographic standard triangle (SST), (fundamental zone) of 
                         the orientation space, it is possible to define a color model which
                         assigns an orientation in the fundamental zone a color.
                         
                         For details see:
                         * [G. Nolze et al.](https://doi.org/10.1107/S1600576716012942)
                         * Srikanth Patala and coworkers&quot;'&quot; work and of others.
                         
                         Details are implementation-specific and not standardized yet.
                         Given that the SST has a complicated geometry, it cannot yet be
                         visualized using tools like H5Web.
                    </doc>
                    <field name="data" type="NX_UINT" units="NX_UNITLESS">
                        <doc>
                             RGB array, with resolution per fastest changing value defined by bitdepth.
                        </doc>
                        <dimensions rank="3">
                            <dim index="1" value="n_y"/>
                            <dim index="2" value="n_x"/>
                            <dim index="3" value="3"/>
                        </dimensions>
                        <attribute name="long_name">
                            <doc>
                                 Naive IPF color map
                            </doc>
                        </attribute>
                    </field>
                    <field name="axis_y" type="NX_NUMBER" units="NX_ANY">
                        <doc>
                             Pixel coordinate along the slow axis.
                        </doc>
                        <dimensions rank="1">
                            <dim index="1" value="n_y"/>
                        </dimensions>
                        <attribute name="long_name">
                            <doc>
                                 Label for the y axis
                            </doc>
                        </attribute>
                    </field>
                    <field name="axis_x" type="NX_NUMBER" units="NX_ANY">
                        <doc>
                             Pixel coordinate along the fast axis.
                        </doc>
                        <dimensions rank="1">
                            <dim index="1" value="n_x"/>
                        </dimensions>
                        <attribute name="long_name">
                            <doc>
                                 Label for the x axis
                            </doc>
                        </attribute>
                    </field>
                </group>
            </group>
        </group>
    </group>
</definition>
